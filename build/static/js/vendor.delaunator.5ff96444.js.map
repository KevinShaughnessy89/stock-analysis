{"version":3,"file":"static/js/vendor.delaunator.5ff96444.js","mappings":"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","sources":["../node_modules/delaunator/index.js"],"sourcesContent":["\nconst EPSILON = Math.pow(2, -52);\nconst EDGE_STACK = new Uint32Array(512);\n\nimport {orient2d} from 'robust-predicates';\n\nexport default class Delaunator {\n\n    static from(points, getX = defaultGetX, getY = defaultGetY) {\n        const n = points.length;\n        const coords = new Float64Array(n * 2);\n\n        for (let i = 0; i < n; i++) {\n            const p = points[i];\n            coords[2 * i] = getX(p);\n            coords[2 * i + 1] = getY(p);\n        }\n\n        return new Delaunator(coords);\n    }\n\n    constructor(coords) {\n        const n = coords.length >> 1;\n        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');\n\n        this.coords = coords;\n\n        // arrays that will store the triangulation graph\n        const maxTriangles = Math.max(2 * n - 5, 0);\n        this._triangles = new Uint32Array(maxTriangles * 3);\n        this._halfedges = new Int32Array(maxTriangles * 3);\n\n        // temporary arrays for tracking the edges of the advancing convex hull\n        this._hashSize = Math.ceil(Math.sqrt(n));\n        this._hullPrev = new Uint32Array(n); // edge to prev edge\n        this._hullNext = new Uint32Array(n); // edge to next edge\n        this._hullTri = new Uint32Array(n); // edge to adjacent triangle\n        this._hullHash = new Int32Array(this._hashSize); // angular edge hash\n\n        // temporary arrays for sorting points\n        this._ids = new Uint32Array(n);\n        this._dists = new Float64Array(n);\n\n        this.update();\n    }\n\n    update() {\n        const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;\n        const n = coords.length >> 1;\n\n        // populate an array of point indices; calculate input data bbox\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0; i < n; i++) {\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n            this._ids[i] = i;\n        }\n        const cx = (minX + maxX) / 2;\n        const cy = (minY + maxY) / 2;\n\n        let i0, i1, i2;\n\n        // pick a seed point close to the center\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist) {\n                i0 = i;\n                minDist = d;\n            }\n        }\n        const i0x = coords[2 * i0];\n        const i0y = coords[2 * i0 + 1];\n\n        // find the point closest to the seed\n        for (let i = 0, minDist = Infinity; i < n; i++) {\n            if (i === i0) continue;\n            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);\n            if (d < minDist && d > 0) {\n                i1 = i;\n                minDist = d;\n            }\n        }\n        let i1x = coords[2 * i1];\n        let i1y = coords[2 * i1 + 1];\n\n        let minRadius = Infinity;\n\n        // find the third point which forms the smallest circumcircle with the first two\n        for (let i = 0; i < n; i++) {\n            if (i === i0 || i === i1) continue;\n            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);\n            if (r < minRadius) {\n                i2 = i;\n                minRadius = r;\n            }\n        }\n        let i2x = coords[2 * i2];\n        let i2y = coords[2 * i2 + 1];\n\n        if (minRadius === Infinity) {\n            // order collinear points by dx (or dy if all x are identical)\n            // and return the list as a hull\n            for (let i = 0; i < n; i++) {\n                this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);\n            }\n            quicksort(this._ids, this._dists, 0, n - 1);\n            const hull = new Uint32Array(n);\n            let j = 0;\n            for (let i = 0, d0 = -Infinity; i < n; i++) {\n                const id = this._ids[i];\n                const d = this._dists[id];\n                if (d > d0) {\n                    hull[j++] = id;\n                    d0 = d;\n                }\n            }\n            this.hull = hull.subarray(0, j);\n            this.triangles = new Uint32Array(0);\n            this.halfedges = new Uint32Array(0);\n            return;\n        }\n\n        // swap the order of the seed points for counter-clockwise orientation\n        if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {\n            const i = i1;\n            const x = i1x;\n            const y = i1y;\n            i1 = i2;\n            i1x = i2x;\n            i1y = i2y;\n            i2 = i;\n            i2x = x;\n            i2y = y;\n        }\n\n        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);\n        this._cx = center.x;\n        this._cy = center.y;\n\n        for (let i = 0; i < n; i++) {\n            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);\n        }\n\n        // sort the points by distance from the seed triangle circumcenter\n        quicksort(this._ids, this._dists, 0, n - 1);\n\n        // set up the seed triangle as the starting hull\n        this._hullStart = i0;\n        let hullSize = 3;\n\n        hullNext[i0] = hullPrev[i2] = i1;\n        hullNext[i1] = hullPrev[i0] = i2;\n        hullNext[i2] = hullPrev[i1] = i0;\n\n        hullTri[i0] = 0;\n        hullTri[i1] = 1;\n        hullTri[i2] = 2;\n\n        hullHash.fill(-1);\n        hullHash[this._hashKey(i0x, i0y)] = i0;\n        hullHash[this._hashKey(i1x, i1y)] = i1;\n        hullHash[this._hashKey(i2x, i2y)] = i2;\n\n        this.trianglesLen = 0;\n        this._addTriangle(i0, i1, i2, -1, -1, -1);\n\n        for (let k = 0, xp, yp; k < this._ids.length; k++) {\n            const i = this._ids[k];\n            const x = coords[2 * i];\n            const y = coords[2 * i + 1];\n\n            // skip near-duplicate points\n            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;\n            xp = x;\n            yp = y;\n\n            // skip seed triangle points\n            if (i === i0 || i === i1 || i === i2) continue;\n\n            // find a visible edge on the convex hull using edge hash\n            let start = 0;\n            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {\n                start = hullHash[(key + j) % this._hashSize];\n                if (start !== -1 && start !== hullNext[start]) break;\n            }\n\n            start = hullPrev[start];\n            let e = start, q;\n            while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {\n                e = q;\n                if (e === start) {\n                    e = -1;\n                    break;\n                }\n            }\n            if (e === -1) continue; // likely a near-duplicate point; skip it\n\n            // add the first triangle from the point\n            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);\n\n            // recursively flip triangles from the point until they satisfy the Delaunay condition\n            hullTri[i] = this._legalize(t + 2);\n            hullTri[e] = t; // keep track of boundary triangles on the hull\n            hullSize++;\n\n            // walk forward through the hull, adding more triangles and flipping recursively\n            let n = hullNext[e];\n            while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {\n                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);\n                hullTri[i] = this._legalize(t + 2);\n                hullNext[n] = n; // mark as removed\n                hullSize--;\n                n = q;\n            }\n\n            // walk backward from the other side, adding more triangles and flipping\n            if (e === start) {\n                while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {\n                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);\n                    this._legalize(t + 2);\n                    hullTri[q] = t;\n                    hullNext[e] = e; // mark as removed\n                    hullSize--;\n                    e = q;\n                }\n            }\n\n            // update the hull indices\n            this._hullStart = hullPrev[i] = e;\n            hullNext[e] = hullPrev[n] = i;\n            hullNext[i] = n;\n\n            // save the two new edges in the hash table\n            hullHash[this._hashKey(x, y)] = i;\n            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;\n        }\n\n        this.hull = new Uint32Array(hullSize);\n        for (let i = 0, e = this._hullStart; i < hullSize; i++) {\n            this.hull[i] = e;\n            e = hullNext[e];\n        }\n\n        // trim typed triangle mesh arrays\n        this.triangles = this._triangles.subarray(0, this.trianglesLen);\n        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);\n    }\n\n    _hashKey(x, y) {\n        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;\n    }\n\n    _legalize(a) {\n        const {_triangles: triangles, _halfedges: halfedges, coords} = this;\n\n        let i = 0;\n        let ar = 0;\n\n        // recursion eliminated with a fixed-size stack\n        while (true) {\n            const b = halfedges[a];\n\n            /* if the pair of triangles doesn't satisfy the Delaunay condition\n             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n             * then do the same check/flip recursively for the new pair of triangles\n             *\n             *           pl                    pl\n             *          /||\\                  /  \\\n             *       al/ || \\bl            al/    \\a\n             *        /  ||  \\              /      \\\n             *       /  a||b  \\    flip    /___ar___\\\n             *     p0\\   ||   /p1   =>   p0\\---bl---/p1\n             *        \\  ||  /              \\      /\n             *       ar\\ || /br             b\\    /br\n             *          \\||/                  \\  /\n             *           pr                    pr\n             */\n            const a0 = a - a % 3;\n            ar = a0 + (a + 2) % 3;\n\n            if (b === -1) { // convex hull edge\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n                continue;\n            }\n\n            const b0 = b - b % 3;\n            const al = a0 + (a + 1) % 3;\n            const bl = b0 + (b + 2) % 3;\n\n            const p0 = triangles[ar];\n            const pr = triangles[a];\n            const pl = triangles[al];\n            const p1 = triangles[bl];\n\n            const illegal = inCircle(\n                coords[2 * p0], coords[2 * p0 + 1],\n                coords[2 * pr], coords[2 * pr + 1],\n                coords[2 * pl], coords[2 * pl + 1],\n                coords[2 * p1], coords[2 * p1 + 1]);\n\n            if (illegal) {\n                triangles[a] = p1;\n                triangles[b] = p0;\n\n                const hbl = halfedges[bl];\n\n                // edge swapped on the other side of the hull (rare); fix the halfedge reference\n                if (hbl === -1) {\n                    let e = this._hullStart;\n                    do {\n                        if (this._hullTri[e] === bl) {\n                            this._hullTri[e] = a;\n                            break;\n                        }\n                        e = this._hullPrev[e];\n                    } while (e !== this._hullStart);\n                }\n                this._link(a, hbl);\n                this._link(b, halfedges[ar]);\n                this._link(ar, bl);\n\n                const br = b0 + (b + 1) % 3;\n\n                // don't worry about hitting the cap: it can only happen on extremely degenerate input\n                if (i < EDGE_STACK.length) {\n                    EDGE_STACK[i++] = br;\n                }\n            } else {\n                if (i === 0) break;\n                a = EDGE_STACK[--i];\n            }\n        }\n\n        return ar;\n    }\n\n    _link(a, b) {\n        this._halfedges[a] = b;\n        if (b !== -1) this._halfedges[b] = a;\n    }\n\n    // add a new triangle given vertex indices and adjacent half-edge ids\n    _addTriangle(i0, i1, i2, a, b, c) {\n        const t = this.trianglesLen;\n\n        this._triangles[t] = i0;\n        this._triangles[t + 1] = i1;\n        this._triangles[t + 2] = i2;\n\n        this._link(t, a);\n        this._link(t + 1, b);\n        this._link(t + 2, c);\n\n        this.trianglesLen += 3;\n\n        return t;\n    }\n}\n\n// monotonically increases with real angle, but doesn't need expensive trigonometry\nfunction pseudoAngle(dx, dy) {\n    const p = dx / (Math.abs(dx) + Math.abs(dy));\n    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]\n}\n\nfunction dist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\n    const dx = ax - px;\n    const dy = ay - py;\n    const ex = bx - px;\n    const ey = by - py;\n    const fx = cx - px;\n    const fy = cy - py;\n\n    const ap = dx * dx + dy * dy;\n    const bp = ex * ex + ey * ey;\n    const cp = fx * fx + fy * fy;\n\n    return dx * (ey * cp - bp * fy) -\n           dy * (ex * cp - bp * fx) +\n           ap * (ex * fy - ey * fx) < 0;\n}\n\nfunction circumradius(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = (ey * bl - dy * cl) * d;\n    const y = (dx * cl - ex * bl) * d;\n\n    return x * x + y * y;\n}\n\nfunction circumcenter(ax, ay, bx, by, cx, cy) {\n    const dx = bx - ax;\n    const dy = by - ay;\n    const ex = cx - ax;\n    const ey = cy - ay;\n\n    const bl = dx * dx + dy * dy;\n    const cl = ex * ex + ey * ey;\n    const d = 0.5 / (dx * ey - dy * ex);\n\n    const x = ax + (ey * bl - dy * cl) * d;\n    const y = ay + (dx * cl - ex * bl) * d;\n\n    return {x, y};\n}\n\nfunction quicksort(ids, dists, left, right) {\n    if (right - left <= 20) {\n        for (let i = left + 1; i <= right; i++) {\n            const temp = ids[i];\n            const tempDist = dists[temp];\n            let j = i - 1;\n            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];\n            ids[j + 1] = temp;\n        }\n    } else {\n        const median = (left + right) >> 1;\n        let i = left + 1;\n        let j = right;\n        swap(ids, median, i);\n        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);\n        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);\n        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);\n\n        const temp = ids[i];\n        const tempDist = dists[temp];\n        while (true) {\n            do i++; while (dists[ids[i]] < tempDist);\n            do j--; while (dists[ids[j]] > tempDist);\n            if (j < i) break;\n            swap(ids, i, j);\n        }\n        ids[left + 1] = ids[j];\n        ids[j] = temp;\n\n        if (right - i + 1 >= j - left) {\n            quicksort(ids, dists, i, right);\n            quicksort(ids, dists, left, j - 1);\n        } else {\n            quicksort(ids, dists, left, j - 1);\n            quicksort(ids, dists, i, right);\n        }\n    }\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultGetX(p) {\n    return p[0];\n}\nfunction defaultGetY(p) {\n    return p[1];\n}\n"],"names":["EPSILON","Math","pow","EDGE_STACK","Uint32Array","Delaunator","from","points","getX","arguments","length","undefined","defaultGetX","getY","defaultGetY","n","coords","Float64Array","i","p","constructor","Error","this","maxTriangles","max","_triangles","_halfedges","Int32Array","_hashSize","ceil","sqrt","_hullPrev","_hullNext","_hullTri","_hullHash","_ids","_dists","update","hullPrev","hullNext","hullTri","hullHash","minX","Infinity","minY","maxX","maxY","x","y","cx","cy","i0","i1","i2","minDist","d","dist","i0x","i0y","i1x","i1y","minRadius","r","circumradius","i2x","i2y","quicksort","hull","j","d0","id","subarray","triangles","halfedges","orient2d","center","ax","ay","bx","by","dx","dy","ex","ey","bl","cl","circumcenter","_cx","_cy","_hullStart","hullSize","fill","_hashKey","trianglesLen","_addTriangle","xp","yp","k","abs","start","key","q","e","t","_legalize","floor","pseudoAngle","a","ar","b","a0","b0","al","p0","pr","pl","p1","inCircle","hbl","_link","br","c","px","py","fx","fy","bp","cp","ids","dists","left","right","temp","tempDist","swap","arr","tmp"],"sourceRoot":""}